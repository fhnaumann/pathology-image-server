import pydicom
import json
import os.path
from pathlib import Path
from pydicom.tag import Tag
import openslide as op
import uuid
import random
import string
from collections.abc import Sequence
import conversion_util
from pydicom.datadict import dictionary_VR
import exceptions
import logging

logging.basicConfig(level=logging.INFO, format="[%(asctime)s] %(levelname)s [%(name)s.%(funcName)s:%(lineno)d] %(message)s", datefmt="%d/%b/%Y %H:%M:%S")
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

def _convert_str_tags_to_dcm_tags(str_tags: list[str]) -> list[Tag]:
    """
    Convert a list of dicom tags (as strings) to a pydicom tag object for convenience.

    :param str_tags: A list of dicom tags formatted as string with the two hexnumbers separated with a "," (e.g. "0010,0010").
    :type str_tags: list[str]
    :return: A list of pydicom tag objects representing the string dicom tags that were given.
    :rtype: list[Tag]
    """
    try:
        return [Tag(tagname) for tagname in str_tags]
    except Exception as e:
        logger.error("Some tags are not formatted correctly %s", e)
        raise exceptions.InvalidTagNameException("Some tags are not formatted correctly (tag name is probably wrong)!") from e
    # tags: list[Tag] = []
    # for str_tag in str_tags:
    #     split = str_tag.split(",")
    #     group = f"0x{split[0]}"
    #     element = f"0x{split[1]}"
    #     tag = Tag(group, element)
    #     tags.append(tag)
    # return tags

mandatory_tags: list[Tag] = []
with open(os.path.join(os.path.dirname(__file__), "mandatory_tags.json"), "r") as f:
    mandatory_tags = _convert_str_tags_to_dcm_tags(json.load(f)["mandatory_tags"])
    # mandatory_tags = _convert_str_tags_to_dcm_tags(str_mandatory_tags)
logger.debug("Loadded mandatory tags: %s", mandatory_tags)



class DicomTagFiller:
    """
    A class used to fill in DICOM tags after the DICOM files were generated by the converter.
    """
    def __init__(self, path_to_dcm_files:str, dcm_tags:dict[str, str]):
        """
        Create a new object.

        :param path_to_dcm_files: The path where the DICOM files exist on the filepath.
        :type path_to_dcm_files: str
        :param dcm_tags: The DICOM tags which will be set in the DICOM files.
        :type dcm_tags: dict[str, str]
        """
        self._path_to_dcm_files = path_to_dcm_files
        self._dcm_tags = dcm_tags
    
def check_for_dcm_conversion_in_proprietary_format(path_to_wsi_file: str):
    image: op.OpenSlide = op.OpenSlide(path_to_wsi_file)
    vendor_specific_dict: dict[str, str] = _get_vendor_specific_dict(image)
    print(vendor_specific_dict)

def _get_vendor_specific_dict(image: op.OpenSlide) -> dict[str, str]:
    vendor_key = image.properties[op.PROPERTY_NAME_VENDOR]
    vendor_specific_dict = {}
    for key in image.properties:
        if vendor_key in key:
            vendor_stripped_key = key.replace(vendor_key, "")[1:]
            value = image.properties.get(key)
            vendor_specific_dict[vendor_stripped_key] = value
    return vendor_specific_dict


def fill_default_metadata_and_dcm_tags(path_to_dcm_files:list[str], business_id: str, str_dcm_keys_values:dict[str, str]) -> list[pydicom.Dataset]:
    """
    Fills in the user supplied dicom tags into the freshly converted dicom files (all of them).

    :param path_to_dcm_files: The path to were the dicom files exist (probably `./temp_data/<uuid>/dicom/`).
    :type path_to_dcm_files: list[str]
    :param str_dcm_keys_values: A dictionary containing the dicom tags as keys and the dicom values as values.
    :type str_dcm_keys_values: dict[str, str]
    :return: All the dicom files in this folder as pydicom objects.
    :rtype: list[pydicom.Dataset]
    """
    dcm_tags: list[Tag] = _convert_str_tags_to_dcm_tags(str_dcm_keys_values.keys())
    dcm_keys_values: dict[Tag, str] = {key: value for key, value in zip(dcm_tags, str_dcm_keys_values.values())}
    
    dcm_datasets: list[pydicom.Dataset] = []
    for dcm_file in path_to_dcm_files:
        with pydicom.dcmread(dcm_file) as ds:
            new_file_name, ds = _fill_default_metadata(ds,business_id=business_id)
            dcm_file_path = Path(dcm_file)
            new_file_path = os.path.join(dcm_file_path.parent, new_file_name)

            for custom_dcm_tag, custom_dcm_value in dcm_keys_values.items():
                try:
                    ds[custom_dcm_tag].value = custom_dcm_value
                    logging.info("Filling tag=%s with value=%s", custom_dcm_tag, custom_dcm_value)
                except KeyError:
                    logging.info("Tag did not exist previously. Creating a new tag=%s with value=%s", custom_dcm_tag, custom_dcm_value)
                    ds.add_new(tag=custom_dcm_tag, VR=dictionary_VR(custom_dcm_tag), value=custom_dcm_value)
                
            ds = _fill_patient_id(ds)
            dcm_datasets.append(ds) 
            ds.save_as(new_file_path)
            logger.info("Saving dataset with path and name=%s", new_file_path)
            # delete old file
            os.remove(dcm_file)
    return dcm_datasets

def _fill_patient_id(dataset) -> pydicom.Dataset:
    tag = Tag("PatientID")
    if tag not in dataset or dataset[tag].is_empty:
        logger.info("Generating uuid for patient ID...")
        dataset[tag].value = str(uuid.uuid4())
    else:
        logger.info("Patient ID is already set.")
    return dataset

def _fill_default_metadata(dataset, business_id: str) -> tuple[str, pydicom.Dataset]:
    # business_uuid = uuid.UUID(f"{{{business_id}}}") # triple curly brackets necessary to produce "{<uuid-with-dashes>}" string
    business_id_as_number = conversion_util.from_uuid_dcm_uid(business_id)

    # every UID fields below has a max size of 64 bytes (which implies 64 character with UTF-8 encoding)

    # StudyInstanceUID has a length of 5+39=44 characters
    dataset.StudyInstanceUID = f"2.25.{business_id_as_number}"
    logger.debug("Set StudyInstanceUID=%s", dataset.StudyInstanceUID)
    # SeriesInstanceUID has a length of 44+2=46 characters
    # hard-code a single value since a single study contains exactly one series in WSI-DICOM files
    dataset.SeriesInstanceUID = f"{dataset.StudyInstanceUID}.1"
    logger.debug("Set SeriesInstanceUID=%s", dataset.SeriesInstanceUID)
    # SOPInstanceUID has a length of 46+1+17=64 characters (max limit)
    # the last 17 digits are randomly generated. The probability of a collision within a single study
    # should be stastically impossible when using average/small tile size and size per dicom object.
    dataset.SOPInstanceUID = f"{dataset.SeriesInstanceUID}.{_generate_random_sop_instance_uid()}"
    logger.debug("Set SOPInstanceUID=%s", dataset.SOPInstanceUID)
    # set Modality (0008,0060) to 'SM' (Slide Microscopy) because FHIR needs it
    dataset.Modality = "SM"
    logger.debug("Set Modality=%s", dataset.Modality)

    return f"{dataset.SOPInstanceUID}.dcm", dataset

def _generate_random_sop_instance_uid():
    return str(random.randrange(0, 10**17))

def validate_no_missing_mandatory_tags(dcm_datasets: list[pydicom.Dataset]) -> list[Tag]:
    """
    Validate that no mandatory tag (can be found in `mandatory_tags.json`) is missing.

    :param dcm_datasets: The pydicom datasets of the converted dicom files.
    :type dcm_datasets: list[pydicom.Dataset]
    :return: A list of tags which are missing. If this list is empty it means no tags are missing the dicom files are ready to be uploaded to the PACS.
    :rtype: list[Tag]
    """
    # only test the first dicom file as they all contain the same (in this case relevant)
    ds = dcm_datasets[0]
    return [mandatory_tag for mandatory_tag in mandatory_tags if mandatory_tag not in ds or ds[mandatory_tag].is_empty]